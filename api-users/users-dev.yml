server:
  port: ${SERVER_PORT:9050}

spring:
  application:
    name: api-users


  # --------------------------------------------------
  # Config de Datasource e Pool de Conexões (PostgreSQL)
  # --------------------------------------------------
  datasource: # Configura o datasource do banco de dados.
    driver-class-name: org.postgresql.Driver # Especifica o driver JDBC (neste caso, para Postgres).
    url: jdbc:postgresql://${DB_HOST:localhost}:${DB_PORT:5432}/${DB_NAME:db-users}?serverTimezone=UTC # Define a URL de conexao ao banco.
    username: ${DB_USERNAME:postgres}
    password: ${DB_PASSWORD:postgres}

    hikari:
      # Se true, cada operação SQL é automaticamente commitada ao fim da execução se não houver transação explícita. true é adequado em cenários simples. Em aplicações com transações claras via Spring, normalmente fica false, pois o controle é feito pelo gerenciador transacional.
      autoCommit: false
      # Nome do pool (útil em logs / monitoramento)
      pool-name: ${spring.application.name}-hikariPool
      # Quantidade mínima de conexões ociosas mantidas no pool
      minimum-idle: 10
      # Quantidade máxima de conexões simultâneas
      maximum-pool-size: 25
      # Define tempo limite de ociosidade para conexões excedentes. Serão removidas após esse tempo.
      idle-timeout: 600000
      # Tempo máximo de vida de uma conexão antes de ser reciclada
      max-lifetime: 1800000
      # Tempo máximo esperando uma conexão antes de erro. Se todas as conexões estiverem em uso e outra requisição chegar, ela espera até 3s. Se passar disso → SQLTransientConnectionException.
      connection-timeout: 3000
      # Timeout de validação de conexão. Evita travamento ao testar conexões ruins.
      validation-timeout: 5000
      # Valida conexão antes de emprestar (para DB instável). Excelente para ambientes com queda ou timeout no DB
      connection-test-query: SELECT 1
      # Os pings periódicos mantêm as conexões ativas e impedem que sejam fechadas pelo banco de dados.
      keepalive-time: 300000
      # Queries internas (validação) rodam separadas da aplicação. Evita interferência em monitoramentos e transações. Recomendado.
      isolate-internal-queries: true
      # Essas configs aumentam performance usando prepared statements, diminuindo roundtrips e reuso de conexões:
      data-source-properties:
        cachePrepStmts: true # Ativa cache de Prepared Statements. Reutiliza queries → aumenta performance.
        prepStmtCacheSize: 250 # Tamanho do cache de statements. Quanto maior, mais reuso (consome memória).
        prepStmtCacheSqlLimit: 2048 # Tamanho máximo da query cacheável. Permite cache de queries grandes.
        useServerPrepStmts: true # Usa prepared statements do servidor, não só em memória. Menos parsing no servidor → ganho real em produção.
        useLocalSessionState: true # Evita roundtrips para verificar estados de sessão. Ganho de performance reduzindo I/O.
        rewriteBatchedStatements: true # Junta statements em batch para enviar em um único pacote. Acelera inserts/lotes (muito eficiente).
        cacheResultSetMetadata: true # Cache de metadados dos ResultSets. Menos comunicação e parsing → aumenta performance.
        cacheServerConfiguration: true # Armazena configurações do servidor localmente. Reduz consultas no handshake e ao longo da execução.
        elideSetAutoCommits: true # Evita chamadas repetidas de setAutoCommit(...). Útil se usa transações com frequência.
        maintainTimeStats: false # Não coleta estatísticas internas de tempo. Reduz overhead, aumenta performance.
  # --------------------------------------------------


  # --------------------------------------------------
  # Config de JPA
  # --------------------------------------------------
  jpa: # Configura o JPA/Hibernate.
    database: POSTGRESQL
    hibernate:
      ddl-auto: none # Define a estrategia de criacao do schema do banco de dados. Pode ser 'none', 'validate', 'update', 'create', 'create-drop'.
      naming:
        physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl # Define a estrategia de nomeacao fisica (padrao). Usar CamelCase no Java e snake_case no banco.
    defer-datasource-initialization: false # True adia a execucao do import.sql ate que o schema JPA esteja inicializado. Usar false com Liquibase.
    properties:
      org:
        hibernate: # Configuracoes avancadas do Hibernate.
          envers:
            audit_table_name: revision_info # Nome da tabela de revisoes do Envers (padrão REVINFO).
            audit_table_suffix: _audit # Sufixo para tabelas de auditoria do Envers (padrão _aud).
            revision_field_name: revision_id # Nome do campo de revisão.
            revision_type_field_name: revision_type # Nome do campo de tipo de revisão.
      hibernate:
        format_sql: true # Formata o SQL gerado para melhor legibilidade.
        use_sql_comments: true # Adiciona comentarios ao SQL gerado.
        connection: # Define o nivel de isolamento de transacao.
          isolation: 2 # Nivel 2 de isolamento recomendado para a maioria dos casos. - 1 = READ_UNCOMMITTED, 2 = READ_COMMITTED, 4 = REPEATABLE_READ, 8 = SERIALIZABLE
        cache:
          use_second_level_cache: false # Habilita cache de segundo nivel. False desabilitado para garantir dados sempre atualizados.
          use_query_cache: false # Habilita cache de consultas. False desabilitado para garantir dados sempre atualizados.
        type:
          enumType:
            type: pgsql_enum # Define o mapeamento de enums para PostgreSQL. Usar 'pgsql_enum' para suporte nativo a enums do PostgreSQL.
    open-in-view: false #  Define se o Hibernate deve manter a sessao aberta durante a renderizacao da view. O false e recomendado para evitar problemas de performance e lazy loading.
    show-sql: true # Habilita a exibicao do SQL gerado no console.
  # --------------------------------------------------


  # --------------------------------------------------
  # Config de Liquibase
  # --------------------------------------------------
  liquibase:
    enabled: true
    change-log: classpath:liquibase/changelog/master.yaml
    default-schema: public
  # --------------------------------------------------


  # --------------------------------------------------
  # Config de Kafka
  # --------------------------------------------------
  kafka:
    bootstrap-servers: kafka-1:9092,kafka-2:9092,kafka-3:9092
    schema.registry.url: http://schema-registry:8081 # Endereço do esquema registry (obrigatório se usar Avro)

    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer # Define como serializar chaves (obrigatório)
      value-serializer: io.confluent.kafka.serializers.KafkaAvroSerializer # Define como serializar o payload/mensagem - pode ser string, json, avro e etc (obrigatório)

      # === Exactly-once (trio sagrado: idempotence, acks e retries) ===
      acks: all # Define se o producer deve esperar confirmação de entrega (0 - Producer nem espera resposta. Envia e esquece / 1 - Producer espera o líder confirmar que gravou. / all ou -1 - Producer espera líder + todas as réplicas ISR confirmarem (ou seja, RF=3 → 3 confirmações).
      enable.idempotence: true # Habilita idempotência (necessário para evitar mensagens duplicadas, incluído em retries). Funciona em conjunto com acks e retries.
      max.in.flight.requests.per.connection: 5 # Permitir múltiplas requisições em voo para maior throughput (padrão 5)
      retries: 2147483647 # Número de tentativas de retentativa (default 2147483647)

      # === Resiliência (funciona com o Retries) ===
      retry.backoff.ms: 100 # Tempo para esperar entre as tentativas (padrão: 100ms)
      retry.backoff.max.ms: 1000 # A quantidade máxima de tempo em milissegundos para esperar ao tentar novamente uma solicitação ao corretor que falhou repetidamente (padrão: 1000).
      request.timeout.ms: 30000 # Controla a quantidade máxima de tempo que o cliente aguardará pela resposta de uma solicitação (padrão: 30000).
      delivery.timeout.ms: 120000 # Tempo máximo para entregar uma mensagem incluindo todas as tentativas (padrão: 120000). Tempo TOTAL para enviar antes de desistir e jogar exceção (Mesmo que tenha milhões de retries, depois de X tempo no total o produtor desiste e joga exceção). Ele controla o ciclo de vida, incluindo: Todas as tentativas de retry; Espera no batch (linger.ms); Tempo de compressão; Tempo de envio pela rede; Espera pelo ack do broker.

      # === Throughput Máximo ===
      batch-size: 131072 # Tamanho máximo (em bytes) que o produtor tenta juntar em um único batch antes de enviar para o broker. Junta várias mensagens num pacote só.
      linger-ms: 5 # Define quanto temo espera até encher o batch (usar obrigatório com batch-size)
      compression-type: zstd # Define como a mensagem será comprimida antes de enviar (none, gzip, snappy, lz4, zstd). Isso reduz o tamanho.

      properties:
        auto.register.schemas: true # registra schema automaticamente (dev OK, prod = false)

    consumer:
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer # Define como desserializar chaves (obrigatório)
      value-deserializer: io.confluent.kafka.serializers.KafkaAvroDeserializer # Define como desserializar o payload/mensagem - pode ser string, json, avro e etc (obrigatório)

      # === Estratégia de rebalance ===
      partition.assignment.strategy: org.apache.kafka.clients.consumer.CooperativeStickyAssignor
      group-id: ${spring.application.name}-v1 # Identificador único do grupo de consumidores. Consumers com o mesmo group.id formam um grupo que divide o trabalho (uma partição → um consumer por grupo). O coordinator usa isso para atribuir partições e armazenar offsets no tópico interno __consumer_offsets.
      group.instance.id: ${spring.application.name}-${STATEFULSET_POD_INDEX:0} # Identificador estático do consumidor. Todos os consumidores do grupo ficam tendo o mesmo ID estático. Então quando o consumidor sai, a partição dele não é reatribuída de imediato e espera por um tempo configurável (session.timeout.ms). Daí, quando um consumidor entrar, essa partição é reatribuída sem ter gerado a ação de rebalance geral. Isso evita o rebalanceamento.
      session.timeout.ms: 45000 # Tempo que o coordinator espera heartbeat antes de marcar o consumidor como morto (padrão 45000).

      # === Forma de leitura e garantia de entrega ===
      auto-offset-reset: latest # latest lê a partir da mensagem mais recente do tópico / earliest lê todas as mensagens do tópico desde o início. Recomendado latest em produção.
      enable-auto-commit: false # O false permite controle sobre o commit (manual ou via Spring). Spring Kafka gerencia com @KafkaListener e Acknowledgment. Obrigatório false em produção.
      # enable-auto-commit false precisa de tópico DLT

      # === Resiliência (funciona com Retries) ===
      request-timeout-ms: 45000 # o tempo limite usado para detectar falhas do cliente

      # === Performance ===
      max-poll-records: 500 # Mais mensagens por poll → menos chamadas de rede (padrão é 500)
      max.poll.interval.ms: 600000 # Tempo máximo entre polls → se passar, expulsa do grupo.

      # === Schema Registry ===
      properties:
        specific.avro.reader: true # Usa SpecificRecord (classes geradas a partir do Avro), não GenericRecord.

    topic:
      events:
        customer-created: events.customer-created-v1
      min.insync.replicas: 2 # O min.insync.replicas configuração trabalha em conjunto com acks=all para controlar a durabilidade.
  # --------------------------------------------------


  # --------------------------------------------------
  # Config de Config Server Client
  # --------------------------------------------------
  config:
    import: optional:configserver:${SPRING_CLOUD_CONFIG_SERVER_URI:http://localhost:8888} # Importa configurações do Config Server. Remover o optional:prefixo fará com que o Cliente de Configuração falhe se não conseguir se conectar ao Servidor de Configuração.
  cloud:
    config:
      profile: ${SPRING_PROFILES_ACTIVE:prod} # Define o perfil ativo (padrão 'dev' se não especificado)
      fail-fast: true # Se true, falha rápido se o Config Server não estiver disponível
      refresh:
        enable: true # Habilita refresh dinâmico das configurações via /actuator/refresh
      retry: # Este bloco de configuração define os parâmetros de retentativa, ou seja, como o cliente deve tentar novamente se a comunicação com o servidor de configuração falhar.
        initial-interval: 3000 # Especifica o intervalo inicial entre as tentativas de retentativa. Neste exemplo, está definido como 3000 milissegundos (ou 3 segundos). Isso significa que o cliente esperará 3 segundos antes de tentar a primeira retentativa após uma falha na comunicação.
        max-interval: 9000 # Define o intervalo máximo entre as tentativas de retentativa. Aqui, está definido como 9000 milissegundos (ou 9 segundos). Isso significa que o intervalo entre as tentativas aumentará progressivamente até atingir esse valor, se a retentativa for necessária várias vezes.
        max-attempts: 1 # Especifica o número máximo de tentativas de retentativa que o cliente fará antes de desistir. Neste caso, está definido como 3. Isso significa que o cliente tentará novamente a comunicação com o servidor de configuração no máximo três vezes antes de desistir.
  # --------------------------------------------------


  # --------------------------------------------------
  # Config de actuator
  # --------------------------------------------------
management:
  endpoints:
    web:
      base-path: /actuator # Define o path base dos endpoints do actuator (padrão /actuator)
      exposure:
        include: refresh,health,info,metrics,configprops,liquibase # Expõe endpoints para monitoramento
  endpoint:
    health:
      show-details: always # Mostra detalhes completos de saúde
    configprops:
      show-values: always # Mostra valores das propriedades de configuração
  # --------------------------------------------------


  # --------------------------------------------------
  # Config de Eureka Client
  # --------------------------------------------------
eureka:
  client:
    register-with-eureka: true # True = Diz: "Registre-se no servidor eureka". False = "Não se registre no servidor eureka".
    fetch-registry: false # True = Diz: "Busque a lista de serviços registrados no servidor eureka". False = "Não busque a lista de serviços registrados no servidor eureka".
    service-url:
      defaultZone: ${SPRING_CLOUD_EUREKA_SERVER_URI:http://localhost:8761/eureka/} # Endereço do Eureka Server
    healthcheck: # Habilita healthcheck. O servidor Eureka periodicamente checa se o cliente está saudável. Se não estiver, o servidor marca como DOWN. Útil para load balancers.
      enabled: true
  # --------------------------------------------------


  # --------------------------------------------------
  # Config de SpringDoc/OpenAPI
  # --------------------------------------------------
springdoc:
  api-docs:
    enabled: true
    path: /api-users/v3/api-docs
  swagger-ui:
    enebled: true
    path: /swagger-ui/v3/index.html
    url: /api-users/v3/api-docs
  # --------------------------------------------------


  # --------------------------------------------------
  # Config de logging
  # --------------------------------------------------
logging:
  level:
    com.zaxxer.hikari: DEBUG
    com.zaxxer.hikari.pool.HikariPool: TRACE
  # --------------------------------------------------

